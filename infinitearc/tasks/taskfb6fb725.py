# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: fb6fb725
Difficulty: insane

=== Tags ===
- Impact highlight
- Contextual rule switch
- Reflective maze
- Pattern alignment
- Fit to bounding box
- Associate colors to colors

=== Description ===
Input grids feature a maze-like structure composed of non-background walls
(colors 1-9) on a zero-background, with a continuous path from the left edge. A
horizontal pattern strip of 2×2 color blocks (e.g., [5, 2, 8]) occupies the top
row, defining a cyclic sequence for path coloring. Below the strip, a rule
matrix of 2×2 blocks is positioned, where each block corresponds to an input
wall color (1-9), and its color encodes a directional vector (e.g., color 3 =
up, color 7 = right). The maze contains reflective wall segments that trigger
direction changes based on the rule matrix.   The output transforms the input by
tracing the path from the left edge, moving right until hitting a wall. The wall
color determines the reflection direction via the rule matrix (e.g., wall color
4 uses rule matrix block 4, which maps to color 9 = down). The path’s color
cycles through the pattern strip sequence, with each reflection point
highlighted by replacing the wall cell with the rule matrix’s color (impact
highlight). The path continues until exiting the grid, adhering strictly to
directional rules without intersections. All input elements (maze, pattern
strip, rule matrix) remain visible, with the output grid size matching the input
and path confined to the maze’s interior bounds.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Deterministic-but-randomized snake path generator that always produces a valid path quickly.
    for attempt in range(50):
        width = random.randint(15, 28)
        height = random.randint(15, 28)
        if width < 8 or height < 8:
            continue

        # Initialize empty grid
        grid_input = [[0 for _ in range(width)] for _ in range(height)]

        # Pattern strip (two rows of 2x2 blocks)
        block_h = 2
        block_w = 2
        max_blocks = min(6, width // block_w)
        num_blocks = random.randint(2, max(2, max_blocks))
        pattern_colors = random.sample(list(range(1, 10)), num_blocks)
        for b in range(num_blocks):
            color = pattern_colors[b]
            col0 = b * block_w
            for r in range(0, block_h):
                for c in range(col0, min(col0 + block_w, width)):
                    grid_input[r][c] = color

        # Rule matrix: 2x2 blocks of size 2 placed under the pattern
        rule_top = block_h
        rule_block_size = 2
        mods = [1, 2, 3, 0]
        random.shuffle(mods)
        rule_block_colors = []
        used = set(pattern_colors)
        for mod in mods:
            candidates = [c for c in range(1, 10) if c % 4 == mod and c not in used]
            if not candidates:
                candidates = [c for c in range(1, 10) if c % 4 == mod]
            col = random.choice(candidates)
            rule_block_colors.append(col)
            used.add(col)

        # Paint the 4 rule blocks (2 rows x 2 cols of 2x2 blocks -> occupies rows rule_top..rule_top+3 and cols 0..3)
        for idx, color in enumerate(rule_block_colors):
            br = idx // 2
            bc = idx % 2
            for r in range(rule_top + br * rule_block_size, rule_top + (br + 1) * rule_block_size):
                for c in range(bc * rule_block_size, (bc + 1) * rule_block_size):
                    if r < height and c < width:
                        grid_input[r][c] = color

        # Reserved cells: pattern + rule matrix
        reserved = set()
        for r in range(height):
            for c in range(width):
                if grid_input[r][c] != 0:
                    reserved.add((r, c))

        # Map rule-block index to directions using the same modulo rule as generator & solver
        mod_to_dir = {1: (0, 1), 2: (-1, 0), 3: (0, -1), 0: (1, 0)}
        idx_to_dir = {i: mod_to_dir[rule_block_colors[i] % 4] for i in range(4)}
        dir_to_idx = {idx_to_dir[i]: i for i in range(4)}

        # Precompute possible wall colors for each index (values 1..9 with (wall-1)%4 == idx)
        idx_to_wall_colors = {}
        for idx in range(4):
            choices = []
            for base in [1, 5, 9]:
                val = idx + base
                if 1 <= val <= 9:
                    choices.append(val)
            if not choices:
                choices = [idx + 1]
            idx_to_wall_colors[idx] = choices

        # Start row (leftmost column). Choose a row safely below the rule matrix so pattern and rule matrix remain visible.
        start_min = rule_top + 2 * rule_block_size
        if start_min >= height - 2:
            continue
        start_row = random.randint(start_min, height - 3)
        # find first zero at or below chosen start_row
        found = False
        for r in range(start_row, height - 1):
            if grid_input[r][0] == 0:
                start_row = r
                found = True
                break
        if not found:
            continue

        start = (start_row, 0)

        # Snake-building variables
        visited = set([start])
        walls = {}
        cur_r, cur_c = start
        horiz_right = True
        success = True

        # We'll snake downwards, alternating horizontal sweeps and single downward steps
        while True:
            # If we are already at the bottom row, path will exit on next move if pointing outwards
            if cur_r >= height - 1:
                break

            if horiz_right:
                # For final rows with not enough room to do a full zig-zag, terminate by moving to the right border and exiting
                if cur_r + 2 >= height:
                    target = width - 1
                    ok = True
                    for c in range(cur_c + 1, target + 1):
                        if (cur_r, c) in reserved or (cur_r, c) in visited:
                            ok = False
                            break
                    if not ok:
                        success = False
                        break
                    for c in range(cur_c + 1, target + 1):
                        visited.add((cur_r, c))
                    cur_c = target
                    break
                # Normal full zigzag: move right to width-2 and place a wall at width-1 to turn down
                found_target = None
                for target in range(width - 2, cur_c, -1):
                    good = True
                    for c in range(cur_c + 1, target + 1):
                        if (cur_r, c) in reserved or (cur_r, c) in visited:
                            good = False
                            break
                    wall_pos = (cur_r, target + 1)
                    if not good:
                        continue
                    if not (0 <= wall_pos[0] < height and 0 <= wall_pos[1] < width):
                        continue
                    if wall_pos in reserved or wall_pos in visited or wall_pos in walls:
                        continue
                    down_pos = (cur_r + 1, target)
                    if not (0 <= down_pos[0] < height and 0 <= down_pos[1] < width):
                        continue
                    if down_pos in reserved or down_pos in visited or down_pos in walls:
                        continue
                    left_turn_wall = (cur_r + 2, target)
                    if not (0 <= left_turn_wall[0] < height and 0 <= left_turn_wall[1] < width):
                        continue
                    if left_turn_wall in reserved or left_turn_wall in visited or left_turn_wall in walls:
                        continue
                    found_target = target
                    break
                if found_target is None:
                    success = False
                    break
                target = found_target
                for c in range(cur_c + 1, target + 1):
                    visited.add((cur_r, c))
                idx_down = dir_to_idx[(1, 0)]
                walls[(cur_r, target + 1)] = random.choice(idx_to_wall_colors[idx_down])
                cur_r = cur_r + 1
                cur_c = target
                visited.add((cur_r, cur_c))
                left_wall_pos = (cur_r + 1, cur_c)
                if not (0 <= left_wall_pos[0] < height and 0 <= left_wall_pos[1] < width):
                    success = False
                    break
                if left_wall_pos in reserved or left_wall_pos in visited or left_wall_pos in walls:
                    success = False
                    break
                idx_left = dir_to_idx[(0, -1)]
                walls[left_wall_pos] = random.choice(idx_to_wall_colors[idx_left])
                horiz_right = False

            else:
                # moving left: similar symmetric logic
                if cur_r + 2 >= height:
                    target = 0
                    ok = True
                    for c in range(cur_c - 1, target - 1, -1):
                        if (cur_r, c) in reserved or (cur_r, c) in visited:
                            ok = False
                            break
                    if not ok:
                        success = False
                        break
                    for c in range(cur_c - 1, target - 1, -1):
                        visited.add((cur_r, c))
                    cur_c = target
                    break
                found_target = None
                for target in range(1, cur_c):
                    good = True
                    for c in range(cur_c - 1, target - 1, -1):
                        if (cur_r, c) in reserved or (cur_r, c) in visited:
                            good = False
                            break
                    wall_pos = (cur_r, target - 1)
                    if not good:
                        continue
                    if not (0 <= wall_pos[0] < height and 0 <= wall_pos[1] < width):
                        continue
                    if wall_pos in reserved or wall_pos in visited or wall_pos in walls:
                        continue
                    down_pos = (cur_r + 1, target)
                    if not (0 <= down_pos[0] < height and 0 <= down_pos[1] < width):
                        continue
                    if down_pos in reserved or down_pos in visited or down_pos in walls:
                        continue
                    right_turn_wall = (cur_r + 2, target)
                    if not (0 <= right_turn_wall[0] < height and 0 <= right_turn_wall[1] < width):
                        continue
                    if right_turn_wall in reserved or right_turn_wall in visited or right_turn_wall in walls:
                        continue
                    found_target = target
                    break
                if found_target is None:
                    success = False
                    break
                target = found_target
                for c in range(cur_c - 1, target - 1, -1):
                    visited.add((cur_r, c))
                idx_down = dir_to_idx[(1, 0)]
                walls[(cur_r, target - 1)] = random.choice(idx_to_wall_colors[idx_down])
                cur_r = cur_r + 1
                cur_c = target
                visited.add((cur_r, cur_c))
                right_wall_pos = (cur_r + 1, cur_c)
                if not (0 <= right_wall_pos[0] < height and 0 <= right_wall_pos[1] < width):
                    success = False
                    break
                if right_wall_pos in reserved or right_wall_pos in visited or right_wall_pos in walls:
                    success = False
                    break
                idx_right = dir_to_idx[(0, 1)]
                walls[right_wall_pos] = random.choice(idx_to_wall_colors[idx_right])
                horiz_right = True

        if not success:
            continue

        # Place walls on grid_input
        for (r, c), colval in list(walls.items()):
            if 0 <= r < height and 0 <= c < width and (r, c) not in reserved:
                grid_input[r][c] = colval

        # Optional decorative walls
        for r in range(rule_top + 2 * rule_block_size, height - 1):
            for c in range(1, width - 1):
                if (r, c) in visited or (r, c) in reserved or (r, c) in walls:
                    continue
                if random.random() < 0.05:
                    grid_input[r][c] = random.randint(1, 9)

        # Build output by simulating the drawing rules exactly
        grid_output = [row[:] for row in grid_input]
        parsed_pattern = []
        col = 0
        while col + 1 < width:
            v = grid_input[0][col]
            if v == 0:
                break
            if grid_input[0][col + 1] == v and grid_input[1][col] == v and grid_input[1][col + 1] == v:
                parsed_pattern.append(v)
                col += block_w
            else:
                break
        if not parsed_pattern:
            parsed_pattern = [1, 2, 3]

        cur_r, cur_c = start
        direction = (0, 1)
        pat_idx = 0
        while True:
            next_r = cur_r + direction[0]
            next_c = cur_c + direction[1]
            if not (0 <= next_r < height and 0 <= next_c < width):
                grid_output[cur_r][cur_c] = parsed_pattern[pat_idx % len(parsed_pattern)]
                break
            if grid_input[next_r][next_c] != 0:
                wall_color = grid_input[next_r][next_c]
                idx = (wall_color - 1) % 4
                highlight = rule_block_colors[idx]
                grid_output[next_r][next_c] = highlight
                grid_output[cur_r][cur_c] = parsed_pattern[pat_idx % len(parsed_pattern)]
                pat_idx += 1
                direction = mod_to_dir[highlight % 4]
            else:
                grid_output[cur_r][cur_c] = parsed_pattern[pat_idx % len(parsed_pattern)]
                pat_idx += 1
                cur_r, cur_c = next_r, next_c

        if grid_input == grid_output:
            continue

        return {'input': grid_input, 'output': grid_output}

    # fallback trivial case
    w, h = 15, 15
    grid_input = [[0] * w for _ in range(h)]
    for r in range(2):
        for c in range(0, 6, 2):
            grid_input[r][c] = grid_input[r][c + 1] = grid_input[r + 1][c] = grid_input[r + 1][c + 1] = 1
    grid_input[2][0] = grid_input[2][1] = grid_input[3][0] = grid_input[3][1] = 2
    grid_input[6][1] = 3
    grid_output = [row[:] for row in grid_input]
    grid_output[6][0] = 1
    grid_output[6][1] = 2
    return {'input': grid_input, 'output': grid_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    # Parse pattern strip (top 2 rows of 2x2 blocks)
    pattern = []
    block_w = 2
    col = 0
    while col + 1 < width:
        v = grid_in[0][col]
        if v == 0:
            break
        if grid_in[0][col + 1] == v and grid_in[1][col] == v and grid_in[1][col + 1] == v:
            pattern.append(v)
            col += block_w
        else:
            break
    if not pattern:
        pattern = [1, 2, 3]

    # Read rule-block colors from rows 2..5 and cols 0..3
    rule_top = 2
    rule_block_size = 2
    rule_block_colors = []
    for idx in range(4):
        br = idx // 2
        bc = idx % 2
        r = rule_top + br * rule_block_size
        c = bc * rule_block_size
        if 0 <= r < height and 0 <= c < width:
            rule_block_colors.append(grid_in[r][c])
        else:
            rule_block_colors.append(1)

    # color -> direction mapping by color%4
    mod_to_dir = {1: (0, 1), 2: (-1, 0), 3: (0, -1), 0: (1, 0)}

    # Try all plausible start rows in the leftmost column (below the rule matrix); choose the one whose simulation
    # does not modify the top area (pattern+rule matrix) and produces a non-empty path.
    start_candidates = [r for r in range(rule_top + 2 * rule_block_size, height) if grid_in[r][0] == 0]
    if not start_candidates:
        for r in range(height):
            if grid_in[r][0] == 0:
                start_candidates.append(r)
    if not start_candidates:
        # nothing free; return input unchanged
        return tuple(tuple(row) for row in grid_in)

    def simulate_from(start_row):
        out = [row[:] for row in grid_in]
        cur_r, cur_c = start_row, 0
        direction = (0, 1)
        pat_idx = 0
        steps = 0
        while True:
            next_r = cur_r + direction[0]
            next_c = cur_c + direction[1]
            if not (0 <= next_r < height and 0 <= next_c < width):
                out[cur_r][cur_c] = pattern[pat_idx % len(pattern)]
                break
            if grid_in[next_r][next_c] != 0:
                wall_color = grid_in[next_r][next_c]
                idx = (wall_color - 1) % 4
                highlight = rule_block_colors[idx]
                out[next_r][next_c] = highlight
                out[cur_r][cur_c] = pattern[pat_idx % len(pattern)]
                pat_idx += 1
                direction = mod_to_dir[highlight % 4]
            else:
                out[cur_r][cur_c] = pattern[pat_idx % len(pattern)]
                pat_idx += 1
                cur_r, cur_c = next_r, next_c
            steps += 1
            if steps > width * height:
                # safety: malfunctioning start, abort
                return None
        return out

    best_out = None
    best_len = -1
    for r in start_candidates:
        candidate = simulate_from(r)
        if candidate is None:
            continue
        # ensure top area (pattern+rule matrix rows) unchanged
        top_rows = rule_top + 2 * rule_block_size
        unchanged_top = True
        for rr in range(top_rows):
            if candidate[rr] != grid_in[rr]:
                unchanged_top = False
                break
        if not unchanged_top:
            continue
        # compute number of changed cells as a measure
        changed = 0
        for rr in range(height):
            for cc in range(width):
                if candidate[rr][cc] != grid_in[rr][cc]:
                    changed += 1
        if changed > best_len:
            best_len = changed
            best_out = candidate
    if best_out is None:
        # fallback to first candidate
        best_out = simulate_from(start_candidates[0])
        if best_out is None:
            return tuple(tuple(row) for row in grid_in)

    return tuple(tuple(row) for row in best_out)
