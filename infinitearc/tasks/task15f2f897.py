# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 15f2f897
Difficulty: hard

=== Tags ===
- Cooperative rule network
- Non overwriting draw
- Gravity

=== Description ===
Input grids feature a background color (0) and multiple distinct colored blocks
(colors 1-9), each block being a connected region of uniform color. Within each
block, a directional protrusion (a single-cell extension) indicates the gravity
direction (e.g., a protrusion to the right implies gravity to the right). The
output grid is derived by extending a trail from each block's protrusion in the
indicated gravity direction until the trail encounters another block or the grid
edge. The trail is drawn on background cells using the block's color. When two
trails intersect, the intersection cell is colored according to a fixed
cooperative rule (e.g., color A and color B intersect to form color C, where C
is determined by a predefined mapping independent of the numerical values of A
and B). The original blocks remain unchanged, and the output includes all trails
and intersections as specified.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def get_intersection(a, b):
    # Cooperative rule: addition modulo 9, represented in 1..9
    # This operation is associative & commutative which makes combining multiple
    # trails deterministic and order-independent.
    c = ( (a % 9) + (b % 9) ) % 9
    return c if c != 0 else 9


def generate():
    """Generate a grid with several 2x2 blocks each with a single-cell protrusion
    that indicates a gravity direction. From each protrusion a trail will extend
    in that direction until it meets another block or the grid edge. Trails are
    drawn on background cells (0). When multiple trails overlap the cell color
    is computed by the cooperative rule get_intersection applied repeatedly.

    Returns:
      A dict {'input': input_grid, 'output': output_grid} with both grids as lists
      of lists of ints between 0 and 9.
    """
    # Grid size
    width = random.randint(15, 30)
    height = random.randint(15, 30)

    # Number of blocks
    num_blocks = random.randint(3, 5)
    colors = random.sample(list(range(1, 10)), num_blocks)

    # We'll retry placement if we fail to place all blocks after many attempts
    max_placement_retries = 200
    placement_retry = 0
    while True:
        placement_retry += 1
        if placement_retry > 1000:
            # Extremely unlikely; fallback to smaller grid to make placement easier
            width = max(6, width // 2)
            height = max(6, height // 2)
            placement_retry = 0
        input_grid = [[0 for _ in range(width)] for _ in range(height)]
        blocks = []  # list of dicts: {color, cells, protrusion, dir}
        occupied = set()
        failed = False
        for color in colors:
            placed = False
            for attempt in range(max_placement_retries):
                # Choose a direction and pick a valid top-left for the 2x2 base
                direction = random.choice(['N', 'S', 'E', 'W'])
                # Determine feasible ranges for the base top-left (r0,c0)
                if direction == 'N':
                    if height < 3: continue
                    r0 = random.randint(1, height - 2)  # r0-1 must be >=0
                    c0 = random.randint(0, width - 2)
                    base = [(r0, c0), (r0, c0 + 1), (r0 + 1, c0), (r0 + 1, c0 + 1)]
                    protrusion = random.choice([(r0 - 1, c0), (r0 - 1, c0 + 1)])
                    dr, dc = -1, 0
                elif direction == 'S':
                    if height < 3: continue
                    r0 = random.randint(0, height - 3)  # r0+2 must be < height
                    c0 = random.randint(0, width - 2)
                    base = [(r0, c0), (r0, c0 + 1), (r0 + 1, c0), (r0 + 1, c0 + 1)]
                    protrusion = random.choice([(r0 + 2, c0), (r0 + 2, c0 + 1)])
                    dr, dc = 1, 0
                elif direction == 'W':
                    if width < 3: continue
                    r0 = random.randint(0, height - 2)
                    c0 = random.randint(1, width - 2)  # c0-1 must be >=0
                    base = [(r0, c0), (r0, c0 + 1), (r0 + 1, c0), (r0 + 1, c0 + 1)]
                    protrusion = random.choice([(r0, c0 - 1), (r0 + 1, c0 - 1)])
                    dr, dc = 0, -1
                else:  # 'E'
                    if width < 3: continue
                    r0 = random.randint(0, height - 2)
                    c0 = random.randint(0, width - 3)  # c0+2 must be < width
                    base = [(r0, c0), (r0, c0 + 1), (r0 + 1, c0), (r0 + 1, c0 + 1)]
                    protrusion = random.choice([(r0, c0 + 2), (r0 + 1, c0 + 2)])
                    dr, dc = 0, 1

                # Validate protrusion in bounds (should be by construction) and no overlap
                r_p, c_p = protrusion
                if not (0 <= r_p < height and 0 <= c_p < width):
                    continue
                candidate_cells = set(base + [protrusion])
                if candidate_cells & occupied:
                    continue

                # Place block
                for (rr, cc) in candidate_cells:
                    input_grid[rr][cc] = color
                blocks.append({
                    'color': color,
                    'cells': candidate_cells,
                    'protrusion': protrusion,
                    'dir': (dr, dc)
                })
                occupied |= candidate_cells
                placed = True
                break
            if not placed:
                failed = True
                break
        if not failed:
            break
        # else retry whole placement

    # Compute independent trails based only on the input grid (background==0 is passable)
    cell_to_colors = {}
    for blk in blocks:
        color = blk['color']
        pr, pc = blk['protrusion']
        dr, dc = blk['dir']
        r, c = pr + dr, pc + dc  # start immediately beyond the protrusion
        path_cells = []
        while 0 <= r < height and 0 <= c < width and input_grid[r][c] == 0:
            path_cells.append((r, c))
            r += dr
            c += dc
        for (rr, cc) in path_cells:
            cell_to_colors.setdefault((rr, cc), []).append(color)

    # Build output grid by combining colors where trails overlap
    output_grid = [row[:] for row in input_grid]
    for (r, c), clist in cell_to_colors.items():
        # combine deterministically (sorted order); but get_intersection is associative
        # so order won't change result. We will still sort to be deterministic.
        combined = clist[0]
        for col in clist[1:]:
            combined = get_intersection(combined, col)
        output_grid[r][c] = combined

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def get_intersection(a, b):
    # Same cooperative rule as in the generator: addition modulo 9 with 0 mapped to 9.
    c = ( (a % 9) + (b % 9) ) % 9
    return c if c != 0 else 9


def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Find connected components (regions) of non-zero colors
    visited = [[False] * width for _ in range(height)]
    regions = []  # list of tuples (color, list_of_cells)
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            color = grid[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            region = []
            while stack:
                cr, cc = stack.pop()
                region.append((cr, cc))
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            regions.append((color, region))

    # For each region find the protrusion cell (a cell in the region with exactly one neighbor
    # inside the region). Then extend a trail from the protrusion in that direction using the
    # input grid as the barrier (trails are independent of each other when determining path cells).
    cell_to_colors = {}
    region_cells_set_cache = []
    for color, region in regions:
        region_set = set(region)
        region_cells_set_cache.append(region_set)
        protrusion = None
        for cell in region:
            neighbors = 0
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                if (cell[0] + dr, cell[1] + dc) in region_set:
                    neighbors += 1
            if neighbors == 1:
                protrusion = cell
                break
        if protrusion is None:
            # No protrusion found for this region; skip
            continue
        # find the neighbor inside the region (the one adjacent to protrusion)
        neighbor = None
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = protrusion[0] + dr, protrusion[1] + dc
            if (nr, nc) in region_set:
                neighbor = (nr, nc)
                break
        if neighbor is None:
            continue
        # direction vector from neighbor to protrusion
        dr = protrusion[0] - neighbor[0]
        dc = protrusion[1] - neighbor[1]

        # Start extending one cell beyond the protrusion
        r, c = protrusion[0] + dr, protrusion[1] + dc
        while 0 <= r < height and 0 <= c < width and grid[r][c] == 0:
            cell_to_colors.setdefault((r, c), []).append(color)
            r += dr
            c += dc

    # Build output by applying the cooperative rule where multiple trails overlap
    output = [row[:] for row in grid]
    for (r, c), clist in cell_to_colors.items():
        combined = clist[0]
        for col in clist[1:]:
            combined = get_intersection(combined, col)
        output[r][c] = combined

    return output

