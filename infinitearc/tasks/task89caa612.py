# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 89caa612
Difficulty: medium

=== Tags ===
- Associate images to bools
- Proximity guessing
- Take minimum
- Image rotation

=== Description ===
The task involves transforming a 2D grid of colors (0-9) through a sequence of
visual operations. The input grids contain distinct color patterns, with color 5
representing a specific "true" image. First, the grid is rotated 90 degrees
clockwise. Then, for each cell in the rotated grid, proximity to the "true"
image (color 5) is checked: if a cell is horizontally or vertically adjacent to
color 5, its value is replaced with the minimum color value found within its 3x3
neighborhood (including itself). Cells not adjacent to color 5 retain their
rotated values. This process combines rotation, proximity-based conditional
replacement, and neighborhood minimum calculation, requiring the solver to
recognize spatial relationships and apply multiple consistent transformations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = common.grid(width, height, 0)
    r, c = random.randint(0, height-1), random.randint(0, width-1)
    input_grid[r][c] = 5
    rotated = [list(x)[::-1] for x in zip(*input_grid)]
    has_adjacent = False
    for i in range(len(rotated)):
        for j in range(len(rotated[0])):
            if rotated[i][j] != 5:
                for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:
                    ni, nj = i + dx, j + dy
                    if 0 <= ni < len(rotated) and 0 <= nj < len(rotated[0]) and rotated[ni][nj] == 5:
                        has_adjacent = True
                        break
                if has_adjacent:
                    break
        if has_adjacent:
            break
    if not has_adjacent:
        return generate()
    output_grid = [[0] * len(rotated[0]) for _ in range(len(rotated))]
    for i in range(len(rotated)):
        for j in range(len(rotated[0])):
            adjacent = False
            for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:
                ni, nj = i + dx, j + dy
                if 0 <= ni < len(rotated) and 0 <= nj < len(rotated[0]) and rotated[ni][nj] == 5:
                    adjacent = True
                    break
            if adjacent:
                min_val = 9
                for di in range(-1, 2):
                    for dj in range(-1, 2):
                        ni, nj = i + di, j + dj
                        if 0 <= ni < len(rotated) and 0 <= nj < len(rotated[0]):
                            if rotated[ni][nj] < min_val:
                                min_val = rotated[ni][nj]
                output_grid[i][j] = min_val
            else:
                output_grid[i][j] = rotated[i][j]
    if input_grid == output_grid:
        return generate()
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    rotated = [list(x)[::-1] for x in zip(*input_grid)]
    output_grid = [[0] * len(rotated[0]) for _ in range(len(rotated))]
    for i in range(len(rotated)):
        for j in range(len(rotated[0])):
            adjacent = False
            for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:
                ni, nj = i + dx, j + dy
                if 0 <= ni < len(rotated) and 0 <= nj < len(rotated[0]) and rotated[ni][nj] == 5:
                    adjacent = True
                    break
            if adjacent:
                min_val = 9
                for di in range(-1, 2):
                    for dj in range(-1, 2):
                        ni, nj = i + di, j + dj
                        if 0 <= ni < len(rotated) and 0 <= nj < len(rotated[0]):
                            if rotated[ni][nj] < min_val:
                                min_val = rotated[ni][nj]
                output_grid[i][j] = min_val
            else:
                output_grid[i][j] = rotated[i][j]
    return output_grid
