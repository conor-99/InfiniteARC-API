# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: f4dff1df
Difficulty: medium–hard

=== Tags ===
- Line decay
- Cyclic coloring
- Rule switch on context
- Image within image
- Outline shapes

=== Description ===
Input grids consist of a uniform background (color 0) with multiple enclosed
regions defined by closed outline shapes (color 1). Each region contains a
central 3×3 embedded image (the "image within image") positioned exactly at the
region's geometric center, surrounded by a consistent border (color 2) that
separates the outline from the embedded grid. The embedded image uses three
distinct, non-background, non-outline colors (A, B, C) arranged in row-major
order (top-left to bottom-right) as a repeating pattern (e.g., [A, B, C; A, B,
C; A, B, C]). The embedded image's top-left color determines the transformation
rule.  The output grid transforms each region by replacing the border (color 2)
with decaying color layers while preserving the outline (color 1) and embedded
image. The decay sequence cycles through the embedded image's colors based on
the top-left color's parity: - If the top-left color is odd (3, 5, 7, 9), the
sequence cycles forward: A → B → C → A → ... - If the top-left color is even (2,
4, 6, 8), the sequence cycles backward: C → B → A → C → ...  Starting from the
outline (color 1), each subsequent inward layer uses the next color in the
sequence. The decay continues until the embedded image is reached, with layers
filling the space between the outline and embedded image. The embedded image
itself remains visible and unchanged in the output. All regions transform
independently, and the background (color 0) remains unaffected. The
transformation requires identifying the embedded image, extracting its top-left
color, determining parity, and applying the cyclic sequence to the interior
layers.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_colors

def generate():
    """Generate an ARC-style pair where each region is a rectangular outline (color 1)
    containing an interior border (color 2) and a centered 3x3 embedded image using
    three distinct colors A,B,C (excluded from 0,1,2). The output replaces the
    interior border (color 2) with decaying layers cycling through A,B,C based on
    the parity of the top-left embedded color A.
    """
    # Choose a moderately sized grid to allow multiple non-overlapping regions
    size = random.randint(11, 21)
    input_grid = grid(size, size, 0)

    # Keep track of occupied cells so regions do not overlap or touch
    occupied = [[False] * size for _ in range(size)]
    regions = []

    # Random number of regions (at least 1)
    num_regions = random.randint(1, 3)
    attempts = 0
    max_attempts = 500

    # Valid odd dimensions that can host a 3x3 center and leave at least one interior layer
    min_dim = 7
    max_dim = min(15, size)
    odd_dims = [d for d in range(min_dim, max_dim + 1) if d % 2 == 1]
    if not odd_dims:
        odd_dims = [7]

    while len(regions) < num_regions and attempts < max_attempts:
        attempts += 1
        height = random.choice(odd_dims)
        width = random.choice(odd_dims)
        r1 = random.randint(0, size - height)
        c1 = random.randint(0, size - width)
        r2 = r1 + height - 1
        c2 = c1 + width - 1

        # Ensure regions don't touch each other (pad by 1)
        pad = 1
        exr1 = max(0, r1 - pad)
        exc1 = max(0, c1 - pad)
        exr2 = min(size - 1, r2 + pad)
        exc2 = min(size - 1, c2 + pad)
        overlap = False
        for rr in range(exr1, exr2 + 1):
            for cc in range(exc1, exc2 + 1):
                if occupied[rr][cc]:
                    overlap = True
                    break
            if overlap:
                break
        if overlap:
            continue

        # Choose three distinct embedded colors excluding background(0), outline(1), border(2)
        A, B, C = random_colors(3, exclude=[0, 1, 2])

        # Draw the outline (color 1)
        for r in range(r1, r2 + 1):
            input_grid[r][c1] = 1
            input_grid[r][c2] = 1
            occupied[r][c1] = True
            occupied[r][c2] = True
        for c in range(c1, c2 + 1):
            input_grid[r1][c] = 1
            input_grid[r2][c] = 1
            occupied[r1][c] = True
            occupied[r2][c] = True

        # Fill the interior with a consistent border color 2
        for r in range(r1 + 1, r2):
            for c in range(c1 + 1, c2):
                input_grid[r][c] = 2
                occupied[r][c] = True

        # Place a centered 3x3 embedded image (row-major repeating A,B,C each row)
        center_r = (r1 + r2) // 2
        center_c = (c1 + c2) // 2
        embed_r = center_r - 1
        embed_c = center_c - 1
        for dr in range(3):
            for dc in range(3):
                input_grid[embed_r + dr][embed_c + dc] = [A, B, C][dc]
                occupied[embed_r + dr][embed_c + dc] = True

        regions.append((r1, r2, c1, c2, A, B, C))

    # If nothing was placed (very unlikely), force a centered region to guarantee a change
    if len(regions) == 0:
        height = width = 7
        r1 = (size - height) // 2
        c1 = (size - width) // 2
        r2 = r1 + height - 1
        c2 = c1 + width - 1
        A, B, C = random_colors(3, exclude=[0, 1, 2])
        for r in range(r1, r2 + 1):
            input_grid[r][c1] = 1
            input_grid[r][c2] = 1
        for c in range(c1, c2 + 1):
            input_grid[r1][c] = 1
            input_grid[r2][c] = 1
        for r in range(r1 + 1, r2):
            for c in range(c1 + 1, c2):
                input_grid[r][c] = 2
        center_r = (r1 + r2) // 2
        center_c = (c1 + c2) // 2
        embed_r = center_r - 1
        embed_c = center_c - 1
        for dr in range(3):
            for dc in range(3):
                input_grid[embed_r + dr][embed_c + dc] = [A, B, C][dc]
        regions.append((r1, r2, c1, c2, A, B, C))

    # Build the output by replacing interior border (2) with decaying layers
    output_grid = [row[:] for row in input_grid]
    for (r1, r2, c1, c2, A, B, C) in regions:
        seq = [A, B, C] if (A % 2 == 1) else [C, B, A]
        # only transform the interior (between the outline rows/cols)
        for r in range(r1 + 1, r2):
            for c in range(c1 + 1, c2):
                if input_grid[r][c] == 2:
                    d = min(r - r1, r2 - r, c - c1, c2 - c)
                    output_grid[r][c] = seq[(d - 1) % 3]

    return {
        "input": input_grid,
        "output": output_grid
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    n = len(grid)
    if n == 0:
        return grid
    m = len(grid[0])

    visited = [[False] * m for _ in range(n)]
    regions = []

    # Find connected components of outline color (1)
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 1 and not visited[i][j]:
                q = deque()
                q.append((i, j))
                visited[i][j] = True
                comp = []
                while q:
                    x, y = q.popleft()
                    comp.append((x, y))
                    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1 and not visited[nx][ny]:
                            visited[nx][ny] = True
                            q.append((nx, ny))
                min_r = min(x for x, _ in comp)
                max_r = max(x for x, _ in comp)
                min_c = min(y for _, y in comp)
                max_c = max(y for _, y in comp)
                regions.append((min_r, max_r, min_c, max_c))

    # For each region, find the centered embedded 3x3 and apply the cyclic decay to color-2 layers
    for (min_r, max_r, min_c, max_c) in regions:
        center_r = (min_r + max_r) // 2
        center_c = (min_c + max_c) // 2
        embed_r = center_r - 1
        embed_c = center_c - 1
        # Validate embed bounds
        if embed_r < 0 or embed_c < 0 or embed_r + 2 >= n or embed_c + 2 >= m:
            continue
        A = grid[embed_r][embed_c]
        B = grid[embed_r][embed_c + 1]
        C = grid[embed_r][embed_c + 2]
        seq = [A, B, C] if (A % 2 == 1) else [C, B, A]

        for r in range(min_r + 1, max_r):
            for c in range(min_c + 1, max_c):
                if grid[r][c] == 2:
                    d = min(r - min_r, max_r - r, c - min_c, max_c - c)
                    grid[r][c] = seq[(d - 1) % 3]

    return grid

