# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: fd1cb764
Difficulty: hard

=== Tags ===
- Pattern cycle
- Direction guessing

=== Description ===
Input grids are 15×15 or larger with a single background color (0), containing a
continuous orthogonal loop of non-background cells forming a closed path without
branches. Each cell in the loop has a color value (1–9) arranged in a repeating
cyclic sequence, with the lowest color (e.g., 1) marking the starting point. The
loop's shape is complex (e.g., winding, non-rectangular, or spanning 8–12
cells), making the cycle direction ambiguous. The sequence must increase
monotonically when traversed in one direction (clockwise or counterclockwise)
and decrease in the opposite direction, but the direction is not explicitly
indicated.   Output grids transform the input by shifting each loop cell's color
to the next in the cycle sequence, determined by inferring the correct traversal
direction. The solver must: (1) identify the loop structure and starting point;
(2) trace the loop in both possible directions from the start; (3) verify which
direction produces a consistent increasing (or decreasing) sequence; (4) apply
the shift (e.g., 1→2, 2→3, 3→1) to all loop cells. The background and non-loop
cells remain unchanged. The challenge lies in correctly deducing the cycle
direction from the color arrangement, as the loop's complexity requires careful
pattern analysis without relying on numerical sums or parity checks.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """
    Robust generator that places a 3x3 perimeter loop (8 cells) somewhere inside a 15-20 grid.
    The loop cells receive unique colors 1..8 in cycle order; the minimum color (1) marks the start.
    The output grid shifts every loop cell to the next color in that cyclic order (1->2, ..., 8->1).
    This deterministic template approach avoids backtracking failures while still producing many unique
    examples by random placement, rotation, reflection, and grid size.
    """
    # Base 3x3 perimeter path (clockwise) starting at top-middle (0,1)
    base = [(0, 1), (0, 2), (1, 2), (2, 2), (2, 1), (2, 0), (1, 0), (0, 0)]

    def rotate_point(p, b, times):
        # rotate point (r,c) in a bxb box times*90 degrees clockwise
        r, c = p
        for _ in range(times % 4):
            r, c = c, b - 1 - r
        return (r, c)

    def reflect_point(p, b):
        r, c = p
        return (r, b - 1 - c)

    size = random.randint(15, 20)
    # choose offset so that a 3x3 box fits inside
    max_offset = size - 3
    ox = random.randint(1, max_offset - 1) if max_offset > 2 else 1
    oy = random.randint(1, max_offset - 1) if max_offset > 2 else 1

    rot = random.randint(0, 3)
    do_reflect = random.choice([False, True])

    path = []
    for p in base:
        rp = rotate_point(p, 3, rot)
        if do_reflect:
            rp = reflect_point(rp, 3)
        # translate
        path.append((rp[0] + ox, rp[1] + oy))

    # build grid and assign colors 1..8 along path order
    grid = [[0 for _ in range(size)] for _ in range(size)]
    L = len(path)
    for i, (r, c) in enumerate(path):
        grid[r][c] = i + 1

    output = [row[:] for row in grid]
    for i, (r, c) in enumerate(path):
        output[r][c] = (grid[r][c] % L) + 1

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to list of lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0]) if H > 0 else 0

    # Collect non-background cells
    loop_cells = [(r, c) for r in range(H) for c in range(W) if grid[r][c] != 0]
    if not loop_cells:
        return grid
    cell_set = set(loop_cells)

    def neighs(pos):
        r, c = pos
        return [(r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)]

    # adjacency among loop cells
    adj = {pos: [n for n in neighs(pos) if n in cell_set] for pos in loop_cells}

    # starting cell: lowest color
    min_color = min(grid[r][c] for (r, c) in loop_cells)
    starts = [pos for pos in loop_cells if grid[pos[0]][pos[1]] == min_color]
    start = starts[0]

    # neighbors of start should be two in a loop
    start_neighbors = adj.get(start, [])
    if not start_neighbors:
        return grid

    # find global sorted unique color list
    all_colors_sorted = sorted({grid[r][c] for (r, c) in loop_cells})

    # preferred successor (the next color in ascending numeric order)
    try:
        k = len(all_colors_sorted)
        succ = all_colors_sorted[(all_colors_sorted.index(min_color) + 1) % k]
    except Exception:
        succ = None

    # Traverse function: walk around the loop following a chosen neighbor until returning to start
    def traverse(start, first):
        seq = [grid[start[0]][start[1]]]
        prev, cur = start, first
        steps = 0
        while True:
            seq.append(grid[cur[0]][cur[1]])
            steps += 1
            # choose next neighbor that's not the previous cell
            nexts = [n for n in adj[cur] if n != prev]
            if not nexts:
                break
            prev, cur = cur, nexts[0]
            if cur == start:
                break
            if steps > 1000:
                break
        return seq

    mapping = None

    # If we can identify the successor color, prefer the neighbor having that color as the forward direction
    if succ is not None:
        chosen = None
        for nb in start_neighbors:
            if grid[nb[0]][nb[1]] == succ:
                chosen = nb
                break
        if chosen is not None:
            seq = traverse(start, chosen)
            U = sorted(set(seq))
            k = len(U)
            mapping = {U[i]: U[(i + 1) % k] for i in range(k)}

    # If the above heuristic didn't produce a mapping, fall back to testing both directions
    if mapping is None:
        for nb in start_neighbors:
            seq = traverse(start, nb)
            unique_colors = sorted(set(seq))
            k = len(unique_colors)
            if k == 0:
                continue
            U = unique_colors
            if seq[0] in U:
                rot = U.index(seq[0])
                forward_match = all(seq[i] == U[(rot + i) % k] for i in range(len(seq)))
                revU = U[::-1]
                backward_match = False
                if seq[0] in revU:
                    rrot = revU.index(seq[0])
                    backward_match = all(seq[i] == revU[(rrot + i) % k] for i in range(len(seq)))

                if forward_match:
                    mapping = {U[i]: U[(i + 1) % k] for i in range(k)}
                    break
                if backward_match:
                    mapping = {revU[i]: revU[(i + 1) % k] for i in range(k)}
                    break

    if mapping is None:
        colors = sorted({grid[r][c] for (r, c) in loop_cells})
        k = len(colors)
        mapping = {colors[i]: colors[(i + 1) % k] for i in range(k)}

    out = [row[:] for row in grid]
    for (r, c) in loop_cells:
        out[r][c] = mapping.get(grid[r][c], grid[r][c])
    return out

