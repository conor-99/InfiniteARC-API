# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 5ab87520
Difficulty: hard

=== Tags ===
- Split and merge
- Repulsion and bounce
- Laser diffusion
- Pattern completion

=== Description ===
# Task Description  Input grids are 25×25 or larger with a uniform background
color (0). Overlaid are multiple distinct colored elements arranged in a complex
spatial pattern:  1. **Laser sources**: Single cells of colors 1-4 positioned
along the grid's perimeter (left, right, top, bottom edges), each emitting a
continuous beam in a direction determined by their edge position (left edge →
right, right edge → left, top edge → down, bottom edge → up).  2. **Obstacle
types**:    - **Mirror (color 5)**: Reflects beams at 90° upon collision (e.g.,
horizontal beam becomes vertical).    - **Splitter (color 6)**: Splits a beam
into two perpendicular beams (e.g., horizontal splits into up and down).    -
**Repulsor (color 7)**: Causes beams to reverse direction (180° bounce) and
diffuse into a 3×3 pattern centered at the collision point, spreading the beam
color diagonally outward (covering all 8 surrounding cells).    - **Merge point
(color 8)**: When two beams of identical color meet at a cell, they merge into a
single beam continuing in the direction of the first beam.  **Transformation
Process**:  1. **Beam propagation**: Each beam travels in its initial direction
until colliding with an obstacle. 2. **Mirror collision**: Beam direction
changes by 90° (e.g., right → up). 3. **Splitter collision**: Beam splits into
two beams traveling perpendicular to original direction (e.g., down splits into
left and right). 4. **Repulsor collision**: Beam reverses direction and
initiates diffusion:    - The collision cell becomes a 3×3 pattern where the
center is the original beam color, and the 8 surrounding cells are filled with
the same color (only in background areas, never over obstacles or other beams).
- Diffused beams continue propagating diagonally from the center outward. 5.
**Merge collision**: Two beams of identical color merging into one beam
(direction preserved from the first beam's path).  **Pattern Completion**:  The
input grid displays a partial symmetric pattern (e.g., a spiral or fractal)
formed by beams interacting with obstacles. The output grid completes this
pattern by fully propagating all beams through the grid, applying all
transformation rules until all beams exit the grid or stabilize. The completed
pattern must form a closed, symmetrical shape (e.g., a diamond or star) that
extends the input's visible pattern. No two beams may occupy the same cell
simultaneously, and diffusion patterns must not overlap with obstacles or other
beams. The background remains unchanged except where modified by beam
propagation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def simulate_beams(input_grid, max_steps_factor=3):
    height = len(input_grid)
    width = len(input_grid[0])
    bg = 0
    # Copy input into output; obstacles present initially but may be overwritten when beams hit
    output = [row[:] for row in input_grid]

    # find sources on perimeter (colors 1-4)
    beams = []
    next_id = 0
    # left edge (col 0), rows 1..h-2
    for r in range(1, height-1):
        v = input_grid[r][0]
        if v in (1,2,3,4):
            beams.append({'r':r,'c':0,'dr':0,'dc':1,'color':v,'id':next_id,'age':0})
            next_id += 1
    # right edge
    for r in range(1, height-1):
        v = input_grid[r][width-1]
        if v in (1,2,3,4):
            beams.append({'r':r,'c':width-1,'dr':0,'dc':-1,'color':v,'id':next_id,'age':0})
            next_id += 1
    # top edge
    for c in range(1, width-1):
        v = input_grid[0][c]
        if v in (1,2,3,4):
            beams.append({'r':0,'c':c,'dr':1,'dc':0,'color':v,'id':next_id,'age':0})
            next_id += 1
    # bottom edge
    for c in range(1, width-1):
        v = input_grid[height-1][c]
        if v in (1,2,3,4):
            beams.append({'r':height-1,'c':c,'dr':-1,'dc':0,'color':v,'id':next_id,'age':0})
            next_id += 1

    if not beams:
        return output

    max_steps = (height*width) * max_steps_factor
    step = 0

    while beams and step < max_steps:
        # Build arrivals mapping
        arrivals = {}
        for b in beams:
            nr = b['r'] + b['dr']
            nc = b['c'] + b['dc']
            # beam exits grid
            if not (0 <= nr < height and 0 <= nc < width):
                continue
            key = (nr, nc)
            arrivals.setdefault(key, []).append(b)

        # If no beams can move (all exiting), break
        if not arrivals:
            break

        next_beams = []
        # deterministic processing order
        for pos in sorted(arrivals.keys()):
            nr, nc = pos
            movers = arrivals[pos]
            # sort movers by id for deterministic tie-breaking
            movers.sort(key=lambda x: x['id'])
            cell_val = input_grid[nr][nc]
            # Determine which movers survive / merge
            if cell_val == 8:
                # merge point: if all movers same color, merge into one; else first wins
                colors = set(b['color'] for b in movers)
                if len(colors) == 1:
                    mover = movers[0]  # merged beam uses direction/color of first mover
                else:
                    mover = movers[0]
            else:
                # normal cell: only first mover persists
                mover = movers[0]

            col = mover['color']
            dr = mover['dr']; dc = mover['dc']

            # Handle interactions
            if cell_val == 5:  # mirror: reflect 90° (CCW)
                output[nr][nc] = col
                new_dr, new_dc = -dc, dr
                nb = {'r':nr,'c':nc,'dr':new_dr,'dc':new_dc,'color':col,'id':next_id,'age':mover['age']+1}
                next_id += 1
                next_beams.append(nb)

            elif cell_val == 6:  # splitter: create two perpendicular beams
                output[nr][nc] = col
                dr1, dc1 = -dc, dr
                dr2, dc2 = dc, -dr
                nb1 = {'r':nr,'c':nc,'dr':dr1,'dc':dc1,'color':col,'id':next_id,'age':mover['age']+1}
                next_id += 1
                nb2 = {'r':nr,'c':nc,'dr':dr2,'dc':dc2,'color':col,'id':next_id,'age':mover['age']+1}
                next_id += 1
                next_beams.append(nb1)
                next_beams.append(nb2)

            elif cell_val == 7:  # repulsor: reverse and diffuse
                # center becomes beam color
                output[nr][nc] = col
                # fill 3x3 pattern around center but only on background cells
                for drn in (-1, 0, 1):
                    for dcn in (-1, 0, 1):
                        r2 = nr + drn; c2 = nc + dcn
                        if 0 <= r2 < height and 0 <= c2 < width:
                            if input_grid[r2][c2] == 0 and output[r2][c2] == 0:
                                output[r2][c2] = col
                # spawn diagonal beams from center for the diagonal neighbors that were filled
                for drn, dcn in [(-1,-1), (-1,1), (1,-1), (1,1)]:
                    r2 = nr + drn; c2 = nc + dcn
                    if 0 <= r2 < height and 0 <= c2 < width and output[r2][c2] == col:
                        nb = {'r':r2,'c':c2,'dr':drn,'dc':dcn,'color':col,'id':next_id,'age':mover['age']+1}
                        next_id += 1
                        next_beams.append(nb)
                # original beam reverses direction and continues from center
                nb_rev = {'r':nr,'c':nc,'dr':-dr,'dc':-dc,'color':col,'id':next_id,'age':mover['age']+1}
                next_id += 1
                next_beams.append(nb_rev)

            else:
                # treat background and merge-cell (8) as enterable: mark and continue
                output[nr][nc] = col
                nb = {'r':nr,'c':nc,'dr':dr,'dc':dc,'color':col,'id':next_id,'age':mover['age']+1}
                next_id += 1
                next_beams.append(nb)

        beams = next_beams
        step += 1

    return output

def generate():
    # Try until we get a nontrivial output (different from input)
    for attempt in range(20):
        width = random.randint(25, 30)
        height = random.randint(25, 30)
        bg = 0
        input_grid = [[bg for _ in range(width)] for _ in range(height)]

        # perimeter candidate positions (exclude corners for clarity)
        perimeter = []
        for r in range(1, height-1):
            perimeter.append((r, 0))
            perimeter.append((r, width-1))
        for c in range(1, width-1):
            perimeter.append((0, c))
            perimeter.append((height-1, c))

        # place a few laser sources (colors 1-4)
        num_sources = random.randint(2, 4)
        num_sources = min(num_sources, len(perimeter))
        sources = random.sample(perimeter, k=num_sources)
        for (r, c) in sources:
            input_grid[r][c] = random.choice([1, 2, 3, 4])

        # place obstacles (5-8) inside the grid (not on perimeter)
        obstacle_types = [5, 6, 7, 8]
        num_obstacles = random.randint(10, 20)
        placed = 0
        tries = 0
        while placed < num_obstacles and tries < num_obstacles * 6:
            tries += 1
            rr = random.randint(1, height-2)
            cc = random.randint(1, width-2)
            if input_grid[rr][cc] != bg:
                continue
            input_grid[rr][cc] = random.choice(obstacle_types)
            placed += 1

        output_grid = simulate_beams(input_grid)

        # ensure the output changed the grid (beams created some markings)
        if output_grid != input_grid:
            return {'input': input_grid, 'output': output_grid}

    # Fallback: return the last attempt even if unchanged (rare)
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple input to mutable list of lists
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    bg = 0

    def simulate_beams(input_grid, max_steps_factor=3):
        height = len(input_grid)
        width = len(input_grid[0])
        output = [row[:] for row in input_grid]
        beams = []
        next_id = 0
        for r in range(1, height-1):
            v = input_grid[r][0]
            if v in (1,2,3,4):
                beams.append({'r':r,'c':0,'dr':0,'dc':1,'color':v,'id':next_id,'age':0})
                next_id += 1
        for r in range(1, height-1):
            v = input_grid[r][width-1]
            if v in (1,2,3,4):
                beams.append({'r':r,'c':width-1,'dr':0,'dc':-1,'color':v,'id':next_id,'age':0})
                next_id += 1
        for c in range(1, width-1):
            v = input_grid[0][c]
            if v in (1,2,3,4):
                beams.append({'r':0,'c':c,'dr':1,'dc':0,'color':v,'id':next_id,'age':0})
                next_id += 1
        for c in range(1, width-1):
            v = input_grid[height-1][c]
            if v in (1,2,3,4):
                beams.append({'r':height-1,'c':c,'dr':-1,'dc':0,'color':v,'id':next_id,'age':0})
                next_id += 1

        if not beams:
            return output

        max_steps = (height*width) * max_steps_factor
        step = 0

        while beams and step < max_steps:
            arrivals = {}
            for b in beams:
                nr = b['r'] + b['dr']
                nc = b['c'] + b['dc']
                if not (0 <= nr < height and 0 <= nc < width):
                    continue
                key = (nr, nc)
                arrivals.setdefault(key, []).append(b)

            if not arrivals:
                break

            next_beams = []
            for pos in sorted(arrivals.keys()):
                nr, nc = pos
                movers = arrivals[pos]
                movers.sort(key=lambda x: x['id'])
                cell_val = input_grid[nr][nc]
                if cell_val == 8:
                    colors = set(b['color'] for b in movers)
                    if len(colors) == 1:
                        mover = movers[0]
                    else:
                        mover = movers[0]
                else:
                    mover = movers[0]

                col = mover['color']
                dr = mover['dr']; dc = mover['dc']

                if cell_val == 5:
                    output[nr][nc] = col
                    new_dr, new_dc = -dc, dr
                    nb = {'r':nr,'c':nc,'dr':new_dr,'dc':new_dc,'color':col,'id':next_id,'age':mover['age']+1}
                    next_id += 1
                    next_beams.append(nb)

                elif cell_val == 6:
                    output[nr][nc] = col
                    dr1, dc1 = -dc, dr
                    dr2, dc2 = dc, -dr
                    nb1 = {'r':nr,'c':nc,'dr':dr1,'dc':dc1,'color':col,'id':next_id,'age':mover['age']+1}
                    next_id += 1
                    nb2 = {'r':nr,'c':nc,'dr':dr2,'dc':dc2,'color':col,'id':next_id,'age':mover['age']+1}
                    next_id += 1
                    next_beams.append(nb1)
                    next_beams.append(nb2)

                elif cell_val == 7:
                    output[nr][nc] = col
                    for drn in (-1, 0, 1):
                        for dcn in (-1, 0, 1):
                            r2 = nr + drn; c2 = nc + dcn
                            if 0 <= r2 < height and 0 <= c2 < width:
                                if input_grid[r2][c2] == 0 and output[r2][c2] == 0:
                                    output[r2][c2] = col
                    for drn, dcn in [(-1,-1), (-1,1), (1,-1), (1,1)]:
                        r2 = nr + drn; c2 = nc + dcn
                        if 0 <= r2 < height and 0 <= c2 < width and output[r2][c2] == col:
                            nb = {'r':r2,'c':c2,'dr':drn,'dc':dcn,'color':col,'id':next_id,'age':mover['age']+1}
                            next_id += 1
                            next_beams.append(nb)
                    nb_rev = {'r':nr,'c':nc,'dr':-dr,'dc':-dc,'color':col,'id':next_id,'age':mover['age']+1}
                    next_id += 1
                    next_beams.append(nb_rev)

                else:
                    output[nr][nc] = col
                    nb = {'r':nr,'c':nc,'dr':dr,'dc':dc,'color':col,'id':next_id,'age':mover['age']+1}
                    next_id += 1
                    next_beams.append(nb)

            beams = next_beams
            step += 1

        return output

    return simulate_beams(input_grid)
